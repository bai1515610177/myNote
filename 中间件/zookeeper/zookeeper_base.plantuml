## zookeeper

> ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性 服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、 负载均衡、命名服
> 务、分布式协调/通知、集群管理、Master 选举、分布式锁和 分布式队列等功能。  

#### 分布式锁

1. 先创建一个临时有序节点znode
2. 客户端扫描 捕获所有的节点，如果发现自己创建的节点顺序最小，则相当于获取了锁，当锁使用结束后，会将节点进行删除
3. 如果发现创建的节点不是最小，则表示没有获取到锁，客户端会找到比自己小的节点并且加入到watcher中进行监听，如果监听到比自己小的被删除则会收到通知，此时再次判断自己创建的是否是最小的，如果不是则继续监听

#### 四种类型znode

1. PERSISTENT 持久化节点

   除非手动删除，否则节点一直存在于 Zookeeper 上  

2. EPHEMRAL 临时节点

   临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点 都会被移除。  

3. PERSISTENT_SEQUENTIAL 持久化顺序节点

   基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维 护的自增整型数字  

4. EPHEMRAL_SEQUENTIAL  临时顺序节点

   基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的 自增整型数字  

#### zookeeper原理

zookeeper的核心是`原子广播`形式，

#### zookeeper是如何保持事务顺序一致性

zookeeper采用全局递增的事务id来标志，所有的proposal（提议）都在被提出的时候加上zxid，zxid 实际上是一个 64 位的数字，高 32 位是
epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两
阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。  

#### zookeeper应用场景

1. 数据发布/订阅
2. 负载均衡
3. 命名服务
4. 分布式协调/通知
5. 集群管理
6. Master选举
7. 分布式锁
8. 分布式队列数据发布/订阅

@startuml "zokeeper lock"
left to right direction
actor c
component zookeeper {
    card "/lock"  as lock
    card "/templock1" as templock1
    card "/templock2" as templock2
    
}
c --> lock  
lock --> templock1
note left: "创建一个临时有序节点"
lock --> templock2
note left: "创建一个临时有序节点"
@enduml



